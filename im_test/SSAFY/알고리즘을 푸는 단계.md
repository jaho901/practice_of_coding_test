### 알고리즘을 푸는 단계

#### 첫번째 단계.

문제를 봤을때 완탐이 되냐 안되냐 (시간복잡도)

(내 실력으로 완탐으로 모든문제를 풀 수 있다는 전제)

#### 두번째 단계.

되면 완탐, 안되면 시간복잡도 줄여야됨, 그것은 문제의 특성에 따라 쓰이는 알고리즘이 갈림.
종이에 시간복잡도 안에 들수 있는거 생각 결국 코테에 나오는 알고리즘은 밑에 5개.

연속된 구간 : 투포인터
경우의수 : DP (경우의수 문제라도 n자체가 10이다 이런 x밥문제는 첫번째단계에서 끝나야됨, 굳이 DP까지 오면안됨)

이 단계에서 이문제의 시간복잡도, 공간복잡도안에 들어갈 확신을 가지면 다음단계, 그전까진 코드를 잡으면 안됨

난 이 문제를 어떻게 풀겠다. 이것이 종이에 적혀있어야됨.
착각을 하면 안되는것 : 나는 이문제를 코딩하겠다 X
밑의 두 과정을 하나로 보면 안됨
이 문제를 종이에 풀고 종이에 푼 것을 코드로 옮기겠다.
손으로 풀 수 있고, 손으로 푼 로직을 코드로 옮길수 있다. (문제해결 능력과 코드구현능력은 별개)

#### 세번째 단계.

어떻게 구현할것인가.

-------------------------------------------------------------

### 알고리즘 과정

완전탐색 : 내가 컴퓨터로 문제를 어떻게 푸느냐를 처음부터 익히겠다.
완전탐색을 처음부터 하는 이유:
(알고리즘을 쓴다는 것은 결국 문제의 모든 state중 쓸모없는 state를 쳐내겠다는 것
state도 볼 줄 모르면서 알고리즘을 쓴다는것은 말이 안됨.
문제를 풀때 완전탐색으로 접근한다는것 자체가 다른알고리즘으로 접근할때 어떤 state를 쳐내야될지 보게되는 것)

백트랙킹 : 똑같은 완전탐색, n중 반복문만으로 안되는 문제를 풀겠다. (시간복잡도 신경 x)
완탐마스터 -> 삼성 코딩테스트 합격가능 (삼성은 구현문제밖에 안내므로)

\+ 정수론(상식)

끝나고 시간복잡도 공부, 이제까지 코드의 시간복잡도를 계산연습.

---

1. DP(동적계획법) : 완탐에서 같은 상태를 여러번 안보기 위한 알고리즘 (__코테문제기준__ 경우의수를 구하는 문제는 무조건 DP)
   (+ DP 최적화 기법 : 메모이제이션)

2. 그리디 : 순서를 정해서 상태자체를 줄이기 위한 알고리즘

3. 이진탐색(파생 투포인터) : 정답이 될수 있는 상태를 절반씩 날려버리는 알고리즘

4. DFS, BFS (그래프) : 완탐.

5. (모노톤)스택o 큐x : 그리디랑 같은 이유로 씀

##### 이 5개마스터 -> 통과못할 코테가 없음 (만점은못받음)

세그먼트 트리, 비트마스킹....그 외 짜잘한 알고리즘 -> 카카오 코테 만점을 노린다면 공부